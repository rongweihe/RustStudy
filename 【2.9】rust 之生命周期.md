# 生命周期

- Rust的每个引用都有自己的生命周期
- 生命周期：引用保持有效的作用域
- 大多数情况下：生命周期是隐式的、可被推断的
- 当引用的生命周期可能以不同的方式互相关联的时候：手动标注生命周期。

生命周期可以说是 Rust 这门语言最大的特点

主要的作用：避免悬垂引用

## 生命周期的省略规则

在 Rust 引用分析中所编入的模式称为生命周期省略规则
- 这些规则无需开发者来遵守
- 它们是一些特殊情况，由编译器考虑
- 如果你的代码符合这些情况，那么就无需显示标注生命周期

生命周期省略规则不会提供完整的推断：
- 如果应用规则后，引用的生命周期仍然模糊不清-》编译错误
- 解决办法：添加生命周期标注，表明引用之间的相互关心

## 生命周期省略的三个规则

- 编译器使用 3 个规则在没有显示标注生命周期的情况下，来确定引用的生命周期
- - 规则 1 应用于输入生命周期
  - 规则 2,3 应用于输出生命周期
  - 如果编译器应用 3 个规则之后，仍然有无法确认的生命周期的引用，-》报错
 
- 规则 1：每个引用类型的参数都有自己的生命周期。
- 规则 2：如果只有 1 个输入生命周期参数，那么该生命周期被赋予给所有输出生命周期参数。
- 规则 3：如果有多个输入生命周期参数，但其中一个是 &self or &mut self(方法) 那么 self 的生命周期就会赋给所有的输出生命周期参数。

## 生命周期的借用检查
为了保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)，来检查我们程序的借用正确性：

```rust
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}
                       // ---------+
```

这段代码和之前的一模一样，唯一的区别在于增加了对变量生命周期的注释。这里，r 变量被赋予了生命周期 'a，x 被赋予了生命周期 'b，从图示上可以明显看出生命周期 'b 比 'a 小很多。

在编译期，Rust 会比较两个变量的生命周期，结果发现 r 明明拥有生命周期 'a，但是却引用了一个小得多的生命周期 'b，在这种情况下，编译器会认为我们的程序存在风险，因此拒绝运行。

如果想要编译通过，也很简单，只要 'b 比 'a 大就好。总之，x 变量只要比 r 活得久，那么 r 就能随意引用 x 且不会存在危险：

```rust
{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```
根据之前的结论，我们重新实现了代码，现在 x 的生命周期 'b 大于 r 的生命周期 'a，因此 r 对 x 的引用是安全的。

通过之前的内容，我们了解了何为生命周期，也了解了 Rust 如何利用生命周期来确保引用是合法的，下面来看看函数中的生命周期。

